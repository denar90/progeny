// Generated by CoffeeScript 1.7.1
'use strict';
var defaultSettings, each, fs, progenyConstructor, sysPath,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

sysPath = require('path');

fs = require('fs-mode');

each = require('async-each');

defaultSettings = function(extname) {
  switch (extname) {
    case 'jade':
      return {
        regexp: /^\s*(?:include|extends)\s+(.+)/
      };
    case 'styl':
      return {
        regexp: /^\s*(?:@import|@require)\s*['"]?([^'"]+)['"]?/,
        exclusion: 'nib'
      };
    case 'less':
      return {
        regexp: /^\s*@import\s*(?:\(\w+\)\s*)?['"]([^'"]+)['"]/
      };
    case 'scss':
    case 'sass':
      return {
        regexp: /^\s*@import\s*['"]?([^'"]+)['"]?/,
        prefix: '_',
        exclusion: /^compass/,
        extensionsList: ['scss', 'sass'],
        multipass: [/@import[^;]+;/g, /\s*['"][^'"]+['"]\s*,?/g, /(?:['"])([^'"]+)/]
      };
  }
};

progenyConstructor = function(mode, settings) {
  var exclusion, extension, extensionsList, multipass, parseDeps, prefix, progeny, progenySync, regexp, rootPath;
  if (settings == null) {
    settings = {};
  }
  rootPath = settings.rootPath, extension = settings.extension, regexp = settings.regexp, prefix = settings.prefix, exclusion = settings.exclusion, extensionsList = settings.extensionsList, multipass = settings.multipass;
  parseDeps = function(path, data, depsList, callback) {
    var altExts, deps, mdeps, parent, prefixed;
    if (path) {
      parent = sysPath.dirname(path);
    }
    mdeps = multipass != null ? multipass.slice(0, -1).reduce(function(vals, regex) {
      return vals.map(function(val) {
        return val.match(regex);
      }).reduce(function(flat, val) {
        return flat.concat(val, []);
      });
    }, [data]).map(function(val) {
      return (val.match(multipass[multipass.length - 1]))[1];
    }) : void 0;
    deps = data.toString().split('\n').map(function(line) {
      return line.match(regexp);
    }).filter(function(match) {
      return (match != null ? match.length : void 0) > 0;
    }).map(function(match) {
      return match[1];
    }).concat(mdeps || []).filter(function(path) {
      if ('[object Array]' !== toString.call(exclusion)) {
        exclusion = [exclusion];
      }
      return !!path && !exclusion.some(function(_exclusion) {
        switch (false) {
          case !(_exclusion instanceof RegExp):
            return _exclusion.test(path);
          case '[object String]' !== toString.call(_exclusion):
            return _exclusion === path;
          default:
            return false;
        }
      });
    }).map(function(path) {
      if (extension && '' === sysPath.extname(path)) {
        return "" + path + "." + extension;
      } else {
        return path;
      }
    }).map(function(path) {
      if (path[0] === '/' || !parent) {
        return sysPath.join(rootPath, path.slice(1));
      } else {
        return sysPath.join(parent, path);
      }
    });
    if (extension) {
      deps.forEach(function(path) {
        if (("." + extension) !== sysPath.extname(path)) {
          return deps.push("" + path + "." + extension);
        }
      });
    }
    if (prefix != null) {
      prefixed = [];
      deps.forEach(function(path) {
        var dir, file;
        dir = sysPath.dirname(path);
        file = sysPath.basename(path);
        if (0 !== file.indexOf(prefix)) {
          return prefixed.push(sysPath.join(dir, "" + prefix + file));
        }
      });
      deps = deps.concat(prefixed);
    }
    if (extensionsList.length) {
      altExts = [];
      deps.forEach(function(path) {
        var dir;
        dir = sysPath.dirname(path);
        return extensionsList.forEach(function(ext) {
          var base;
          if (("." + ext) !== sysPath.extname(path)) {
            base = sysPath.basename(path, "." + extension);
            return altExts.push(sysPath.join(dir, "" + base + "." + ext));
          }
        });
      });
      deps = deps.concat(altExts);
    }
    if (deps.length) {
      return each(deps, function(path, callback) {
        if (__indexOf.call(depsList, path) >= 0) {
          return callback();
        } else {
          depsList.push(path);
          return fs[mode].readFile(path, {
            encoding: 'utf8'
          }, function(err, data) {
            if (err) {
              return callback();
            }
            return parseDeps(path, data, depsList, callback);
          });
        }
      }, callback);
    } else {
      return callback();
    }
  };
  progeny = function(path, data, callback) {
    var def, depsList, run;
    if (typeof data === 'function') {
      callback = data;
      data = void 0;
    }
    depsList = [];
    if (extension == null) {
      extension = sysPath.extname(path).slice(1);
    }
    def = defaultSettings(extension);
    if (regexp == null) {
      regexp = def.regexp;
    }
    if (prefix == null) {
      prefix = def.prefix;
    }
    if (exclusion == null) {
      exclusion = def.exclusion;
    }
    if (extensionsList == null) {
      extensionsList = def.extensionsList || [];
    }
    if (multipass == null) {
      multipass = def.multipass;
    }
    run = function() {
      return parseDeps(path, data, depsList, function() {
        return callback(null, depsList);
      });
    };
    if (data != null) {
      return run();
    } else {
      return fs[mode].readFile(path, {
        encoding: 'utf8'
      }, function(err, fileContents) {
        if (err) {
          return callback(err);
        }
        data = fileContents;
        return run();
      });
    }
  };
  progenySync = function(path, data) {
    var result;
    result = [];
    progeny(path, data, function(err, depsList) {
      if (err) {
        throw err;
      }
      return result = depsList;
    });
    return result;
  };
  if (mode === 'Sync') {
    return progenySync;
  } else {
    return progeny;
  }
};

module.exports = progenyConstructor.bind(null, 'Async');

module.exports.Sync = progenyConstructor.bind(null, 'Sync');
